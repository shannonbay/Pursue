### 4.1.5 Authentication & Token Management Implementation

This section defines the critical implementation details for handling authentication, token refresh, and session management in the Android app.

#### 4.1.5.1 Token Storage & Security

**Token Types:**
- **Access Token**: Short-lived (15 minutes), used for API authentication
- **Refresh Token**: Long-lived (30 days), used to obtain new access tokens

**Storage Implementation:**
```kotlin
class SecureTokenManager(context: Context) {
    private val masterKey = MasterKey.Builder(context)
        .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
        .build()
    
    private val encryptedPrefs = EncryptedSharedPreferences.create(
        context,
        "auth_tokens",
        masterKey,
        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
    )
    
    fun saveTokens(accessToken: String, refreshToken: String) {
        encryptedPrefs.edit()
            .putString("access_token", accessToken)
            .putString("refresh_token", refreshToken)
            .apply()
    }
    
    fun getAccessToken(): String? = encryptedPrefs.getString("access_token", null)
    
    fun getRefreshToken(): String? = encryptedPrefs.getString("refresh_token", null)
    
    fun clearTokens() {
        encryptedPrefs.edit()
            .remove("access_token")
            .remove("refresh_token")
            .apply()
    }
}
```

#### 4.1.5.2 OkHttp Interceptor for Authorization Headers

**Add access token to all authenticated requests:**
```kotlin
class AuthInterceptor(
    private val tokenManager: SecureTokenManager
) : Interceptor {
    
    override fun intercept(chain: Interceptor.Chain): Response {
        val originalRequest = chain.request()
        
        // Skip auth header for login/register/refresh endpoints
        val url = originalRequest.url.toString()
        if (url.contains("/auth/login") || 
            url.contains("/auth/register") || 
            url.contains("/auth/refresh") ||
            url.contains("/auth/google")) {
            return chain.proceed(originalRequest)
        }
        
        // Add Authorization header with access token
        val accessToken = tokenManager.getAccessToken()
        val authenticatedRequest = if (accessToken != null) {
            originalRequest.newBuilder()
                .header("Authorization", "Bearer $accessToken")
                .build()
        } else {
            originalRequest
        }
        
        return chain.proceed(authenticatedRequest)
    }
}
```

#### 4.1.5.3 Token Refresh Authenticator

**Critical: Handle 401 responses and token refresh logic**

This is the MOST IMPORTANT part of authentication. When ANY request receives a 401 response:
1. Attempt to refresh the access token using the refresh token
2. If refresh succeeds, retry the original request with new token
3. If refresh fails (500, 401, any error), IMMEDIATELY clear tokens and navigate to login

```kotlin
class TokenAuthenticator(
    private val tokenManager: SecureTokenManager,
    private val apiService: ApiService,
    private val onLogout: () -> Unit  // Callback to navigate to login screen
) : Authenticator {
    
    override fun authenticate(route: Route?, response: Response): Request? {
        // If we already tried to refresh and still got 401, give up
        if (response.request.header("Authorization-Retry") != null) {
            Log.e("TokenAuthenticator", "Already attempted refresh, clearing tokens")
            clearTokensAndSignOut()
            return null
        }
        
        val refreshToken = tokenManager.getRefreshToken()
        if (refreshToken == null) {
            Log.e("TokenAuthenticator", "No refresh token available")
            clearTokensAndSignOut()
            return null
        }
        
        // Synchronously refresh the token
        return try {
            Log.d("TokenAuthenticator", "Attempting token refresh")
            val refreshResponse = apiService.refreshToken(
                RefreshTokenRequest(refreshToken)
            ).execute()
            
            when {
                refreshResponse.isSuccessful -> {
                    val newAccessToken = refreshResponse.body()?.access_token
                    if (newAccessToken != null) {
                        Log.d("TokenAuthenticator", "Token refresh successful")
                        // Save new access token (keep existing refresh token)
                        tokenManager.saveTokens(newAccessToken, refreshToken)
                        
                        // Retry original request with new token
                        response.request.newBuilder()
                            .header("Authorization", "Bearer $newAccessToken")
                            .header("Authorization-Retry", "true")
                            .build()
                    } else {
                        Log.e("TokenAuthenticator", "Refresh succeeded but no token in response")
                        clearTokensAndSignOut()
                        null
                    }
                }
                refreshResponse.code() == 401 -> {
                    // Refresh token is invalid or expired
                    Log.e("TokenAuthenticator", "Refresh token invalid (401)")
                    clearTokensAndSignOut()
                    null
                }
                else -> {
                    // Server error (500), network error, etc.
                    Log.e("TokenAuthenticator", "Token refresh failed with code ${refreshResponse.code()}")
                    clearTokensAndSignOut()
                    null
                }
            }
        } catch (e: Exception) {
            Log.e("TokenAuthenticator", "Token refresh exception: ${e.message}", e)
            clearTokensAndSignOut()
            null
        }
    }
    
    private fun clearTokensAndSignOut() {
        Log.d("TokenAuthenticator", "Clearing tokens and signing out")
        tokenManager.clearTokens()
        // Navigate to login screen on main thread
        android.os.Handler(android.os.Looper.getMainLooper()).post {
            onLogout()
        }
    }
}
```

#### 4.1.5.4 OkHttp Client Configuration

**Wire everything together:**
```kotlin
class ApiClientBuilder(
    private val context: Context,
    private val baseUrl: String
) {
    
    private val tokenManager = SecureTokenManager(context)
    
    fun build(onLogout: () -> Unit): ApiService {
        val okHttpClient = OkHttpClient.Builder()
            .addInterceptor(AuthInterceptor(tokenManager))
            .authenticator(TokenAuthenticator(tokenManager, buildApiService(), onLogout))
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .build()
        
        val retrofit = Retrofit.Builder()
            .baseUrl(baseUrl)
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
        
        return retrofit.create(ApiService::class.java)
    }
    
    private fun buildApiService(): ApiService {
        // Minimal client for token refresh (no authenticator to avoid recursion)
        val minimalClient = OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .build()
            
        return Retrofit.Builder()
            .baseUrl(baseUrl)
            .client(minimalClient)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
            .create(ApiService::class.java)
    }
}
```

#### 4.1.5.5 Critical Error Handling Rules

**MUST FOLLOW THESE RULES:**

1. **ANY 401 Response = Complete Logout**
    - Clear both access_token AND refresh_token from encrypted storage
    - Navigate to login screen with cleared back stack (user cannot go back)
    - This applies to:
        - 401 errors during automatic token refresh
        - 401 errors on any API endpoint after failed refresh
        - ANY other 401 response

2. **Token Refresh Failures = Complete Logout**
    - If token refresh returns 500 (server error): Clear tokens, logout
    - If token refresh returns 401 (invalid refresh token): Clear tokens, logout
    - If token refresh throws exception (network error): Clear tokens, logout
    - If token refresh succeeds but response is malformed: Clear tokens, logout

3. **Do NOT Retry on 401**
    - After clearing tokens, do NOT attempt to retry the original request
    - Show login screen immediately
    - User must re-authenticate

4. **Database Migration Scenario**
    - When backend database changes, old refresh tokens become invalid
    - Backend returns 500 on `/auth/refresh` (database connection error)
    - App must handle this gracefully:
        - Detect refresh failure (ANY error code)
        - Clear all local tokens
        - Navigate to login screen
        - User re-authenticates with new database

5. **Prevent Infinite Retry Loops**
    - Use `Authorization-Retry` header to detect if we already attempted refresh
    - If retry request also gets 401, immediately logout (don't try again)

#### 4.1.5.6 Navigation on Logout

**Clear navigation stack when logging out:**
```kotlin
fun navigateToLogin(navController: NavController) {
    navController.navigate("login") {
        // Clear entire back stack
        popUpTo(0) { inclusive = true }
        // Prevent multiple copies
        launchSingleTop = true
    }
}
```

**In MainActivity or root composable:**
```kotlin
val apiClient = remember {
    ApiClientBuilder(context, BuildConfig.API_BASE_URL).build(
        onLogout = {
            // This runs when authentication fails
            navigateToLogin(navController)
            // Show toast to inform user
            Toast.makeText(
                context,
                "Session expired. Please log in again.",
                Toast.LENGTH_LONG
            ).show()
        }
    )
}
```

#### 4.1.5.7 Testing Checklist

**Test these scenarios thoroughly:**

- [ ] Normal token refresh (401 → refresh → retry succeeds)
- [ ] Expired refresh token (401 → refresh fails with 401 → logout)
- [ ] Server error during refresh (401 → refresh fails with 500 → logout)
- [ ] Network error during refresh (401 → exception → logout)
- [ ] Infinite retry prevention (401 → refresh → 401 again → logout, not retry)
- [ ] Database migration scenario (all old tokens invalid → logout)
- [ ] Token cleared from storage after logout
- [ ] Cannot navigate back to authenticated screens after logout
- [ ] User can log in again after automatic logout

---

