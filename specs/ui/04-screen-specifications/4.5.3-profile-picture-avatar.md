### 4.5.3 Profile Picture (Avatar)

**Current Profile Display:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                  ‚îÇ
‚îÇ        ‚îÇ  [IMG]  ‚îÇ  ‚Üê Tap to change ‚îÇ
‚îÇ        ‚îÇ Shannon ‚îÇ                  ‚îÇ
‚îÇ        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                  ‚îÇ
‚îÇ                                     ‚îÇ
‚îÇ     Shannon Thompson                ‚îÇ
‚îÇ     [Edit Profile Picture]          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Avatar Display Logic:**
```kotlin
// Load avatar from backend
if (user.has_avatar) {
    Glide.with(context)
        .load("${apiBaseUrl}/users/${user.id}/avatar")
        .circleCrop()
        .placeholder(R.drawable.default_avatar)
        .error(R.drawable.default_avatar)
        .into(avatarImageView)
} else {
    // Show default avatar (first letter of name)
    val initial = user.display_name.first().uppercase()
    avatarImageView.setImageDrawable(
        LetterAvatarDrawable(initial, Color.parseColor("#1976D2"))
    )
}
```

**Upload Avatar Flow:**

**Step 1: Select Source**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Change Profile Picture              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ
‚îÇ ‚îÇ üì∑ Take Photo                   ‚îÇ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ
‚îÇ ‚îÇ üñºÔ∏è  Choose from Gallery         ‚îÇ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ
‚îÇ ‚îÇ üóëÔ∏è  Remove Photo                ‚îÇ‚îÇ ‚Üê Only if has_avatar = true
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
‚îÇ                                     ‚îÇ
‚îÇ [Cancel]                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Step 2: Crop Image (Android Image Cropper Library)**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ‚Üê Crop Image                 [Done] ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                     ‚îÇ
‚îÇ      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
‚îÇ      ‚îÇ                   ‚îÇ          ‚îÇ
‚îÇ      ‚îÇ   [IMAGE PREVIEW] ‚îÇ          ‚îÇ
‚îÇ      ‚îÇ   with crop box   ‚îÇ          ‚îÇ
‚îÇ      ‚îÇ                   ‚îÇ          ‚îÇ
‚îÇ      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
‚îÇ                                     ‚îÇ
‚îÇ   [Rotate]  [Flip]  [Reset]         ‚îÇ
‚îÇ                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Step 3: Upload**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Uploading...                        ‚îÇ
‚îÇ                                     ‚îÇ
‚îÇ     ‚è≥  Processing image             ‚îÇ
‚îÇ                                     ‚îÇ
‚îÇ     [Progress bar 60%]              ‚îÇ
‚îÇ                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Implementation (Android):**

```kotlin
// Select image from gallery
val pickImageLauncher = registerForActivityResult(
    ActivityResultContracts.GetContent()
) { uri: Uri? ->
    uri?.let { startImageCrop(it) }
}

fun selectFromGallery() {
    pickImageLauncher.launch("image/*")
}

// Take photo with camera
val takePictureLauncher = registerForActivityResult(
    ActivityResultContracts.TakePicture()
) { success ->
    if (success) {
        photoUri?.let { startImageCrop(it) }
    }
}

fun takePhoto() {
    val photoFile = createTempImageFile()
    photoUri = FileProvider.getUriForFile(
        context,
        "${context.packageName}.fileprovider",
        photoFile
    )
    takePictureLauncher.launch(photoUri)
}

// Crop image (using Android Image Cropper)
val cropImageLauncher = registerForActivityResult(
    CropImageContract()
) { result ->
    if (result.isSuccessful) {
        result.uriContent?.let { uploadAvatar(it) }
    }
}

fun startImageCrop(imageUri: Uri) {
    val cropOptions = CropImageContractOptions(imageUri, CropImageOptions(
        aspectRatioX = 1,
        aspectRatioY = 1,
        fixAspectRatio = true,
        outputCompressFormat = Bitmap.CompressFormat.JPEG,
        outputCompressQuality = 90,
        maxOutputSizeX = 512,
        maxOutputSizeY = 512
    ))
    cropImageLauncher.launch(cropOptions)
}

// Upload to backend
suspend fun uploadAvatar(imageUri: Uri) {
    try {
        showLoading(true)
        
        // Compress image before upload to reduce bandwidth
        // Backend will resize again to 256x256, but this saves upload time
        val bitmap = BitmapFactory.decodeStream(
            context.contentResolver.openInputStream(imageUri)
        )
        
        // Resize to max 512x512 if larger (backend resizes to 256x256 anyway)
        val resizedBitmap = if (bitmap.width > 512 || bitmap.height > 512) {
            Bitmap.createScaledBitmap(bitmap, 512, 512, true)
        } else {
            bitmap
        }
        
        // Compress to JPEG (quality 85) - reduces file size for upload
        val outputStream = ByteArrayOutputStream()
        resizedBitmap.compress(Bitmap.CompressFormat.JPEG, 85, outputStream)
        val imageBytes = outputStream.toByteArray()
        
        // Clean up
        if (resizedBitmap != bitmap) {
            resizedBitmap.recycle()
        }
        bitmap.recycle()
        
        val requestBody = imageBytes.toRequestBody("image/jpeg".toMediaType())
        
        val multipartBody = MultipartBody.Part.createFormData(
            "avatar",
            "avatar.jpg",
            requestBody
        )
        
        val response = apiClient.uploadAvatar(multipartBody)
        
        if (response.isSuccessful) {
            // Update local user state
            userViewModel.updateHasAvatar(true)
            
            // Reload avatar
            loadAvatar()
            
            Toast.makeText(context, "Profile picture updated!", Toast.LENGTH_SHORT).show()
        } else {
            Toast.makeText(context, "Upload failed", Toast.LENGTH_SHORT).show()
        }
    } catch (e: Exception) {
        Toast.makeText(context, "Error: ${e.message}", Toast.LENGTH_SHORT).show()
    } finally {
        showLoading(false)
    }
}

/**
 * Why resize on client?
 * - Original photo: 4000x3000, ~8 MB
 * - After crop: 512x512, ~200 KB JPEG
 * - After client resize + compress: 512x512, ~50 KB JPEG ‚Üê Upload this
 * - Backend resizes to: 256x256, ~30 KB WebP
 * 
 * Result: 4x smaller upload (200 KB ‚Üí 50 KB), faster upload on slow networks
 */

// Remove avatar
suspend fun removeAvatar() {
    try {
        val response = apiClient.deleteAvatar()
        
        if (response.isSuccessful) {
            userViewModel.updateHasAvatar(false)
            loadAvatar() // Will show letter avatar
            Toast.makeText(context, "Profile picture removed", Toast.LENGTH_SHORT).show()
        }
    } catch (e: Exception) {
        Toast.makeText(context, "Error: ${e.message}", Toast.LENGTH_SHORT).show()
    }
}
```

**API Interface (Retrofit):**
```kotlin
interface ApiService {
    @Multipart
    @POST("users/me/avatar")
    suspend fun uploadAvatar(
        @Part avatar: MultipartBody.Part
    ): Response<UploadAvatarResponse>
    
    @GET("users/{userId}/avatar")
    suspend fun getAvatar(
        @Path("userId") userId: String
    ): Response<ResponseBody>
    
    @DELETE("users/me/avatar")
    suspend fun deleteAvatar(): Response<DeleteAvatarResponse>
}

data class UploadAvatarResponse(
    val success: Boolean,
    val has_avatar: Boolean
)

data class DeleteAvatarResponse(
    val success: Boolean,
    val has_avatar: Boolean
)
```

**Caching Strategy:**

```kotlin
// Use Glide's disk cache
Glide.with(context)
    .load("${apiBaseUrl}/users/${userId}/avatar")
    .diskCacheStrategy(DiskCacheStrategy.ALL) // Cache original + transformed
    .signature(ObjectKey(user.updated_at)) // Invalidate when user updates
    .circleCrop()
    .into(imageView)
```

**Dependencies (build.gradle.kts):**
```kotlin
dependencies {
    // Image loading
    implementation("com.github.bumptech.glide:glide:4.16.0")
    
    // Image cropping
    implementation("com.vanniktech:android-image-cropper:4.5.0")
    
    // Multipart upload
    implementation("com.squareup.okhttp3:okhttp:4.12.0")
    implementation("com.squareup.retrofit2:retrofit:2.9.0")
}
```

**File Provider (res/xml/file_paths.xml):**
```xml
<?xml version="1.0" encoding="utf-8"?>
<paths>
    <cache-path name="avatar_cache" path="avatars/" />
</paths>
```

**AndroidManifest.xml:**
```xml
<provider
    android:name="androidx.core.content.FileProvider"
    android:authorities="${applicationId}.fileprovider"
    android:exported="false"
    android:grantUriPermissions="true">
    <meta-data
        android:name="android.support.FILE_PROVIDER_PATHS"
        android:resource="@xml/file_paths" />
</provider>

<uses-permission android:name="android.permission.CAMERA" />
<uses-feature android:name="android.hardware.camera" android:required="false" />
```

**Error Handling:**

- File too large (>5 MB): "Image too large. Please choose a smaller image."
- Invalid file type: "Please select a valid image (PNG, JPG, WebP)"
- Network error: "Upload failed. Check your connection and try again."
- Server error: "Unable to upload. Please try again later."

**Notes:**
- Backend automatically resizes to 256x256 and converts to WebP
- Android can send any size/format - backend handles processing
- Use ETag caching to avoid re-downloading unchanged avatars
- Letter avatars shown as fallback when no image uploaded

---

